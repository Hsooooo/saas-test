<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- @Getter
@Getter
@Setter
@Alias("KnowledgeGardenNodeVO")
public class KnowledgeGardenNodeVO {
    private Integer idx;
    private Integer partnershipMemberIdx;
    private String label;
    private String typeCd;
    private Integer parentNodeIdx;
    private Double sortOrder;
    private Integer depth;
    private Integer currentVersionIdx;
    private String stateCd;
    private String noteStatusCd;
    private Integer viewCount;
    private String updateDate;
    private String createDate;
}

 -->
<mapper namespace="com.illunex.emsaasrestapi.knowledge.mapper.KnowledgeGardenNodeMapper">

    <insert id="insertByKnowledgeGardenNodeVO" parameterType="KnowledgeGardenNodeVO" useGeneratedKeys="true" keyProperty="idx">
        INSERT INTO knowledge_garden_node
            (partnership_member_idx, label, type_cd, parent_node_idx, sort_order, depth, current_version_idx, state_cd, note_status_cd, view_count, create_date, update_date)
        VALUES
            (#{partnershipMemberIdx}, #{label}, #{typeCd}, #{parentNodeIdx}, #{sortOrder}, #{depth}, #{currentVersionIdx}, #{stateCd}, #{noteStatusCd}, #{viewCount}, NOW(), NOW());
    </insert>

    <select id="selectByIdx" resultType="KnowledgeGardenNodeVO">
        SELECT *
          FROM knowledge_garden_node
         WHERE idx = #{idx}
    </select>

    <select id="selectBySearchFolder" resultType="KnowledgeGardenNodeVO">
        SELECT
            *
        FROM knowledge_garden_node n
        WHERE n.partnership_member_idx = #{partnershipMemberIdx}
          AND n.type_cd = #{typeCd}
          AND n.state_cd = 'KNS0001'
          AND n.label LIKE CONCAT('%', #{searchStr}, '%')     -- 부분 일치
        ORDER BY n.label
        LIMIT #{limit}
    </select>

    <select id="selectTreeNodes" resultType="KnowledgeGardenNodeViewVO">
        SELECT
            *,
            CASE WHEN c.child_cnt > 0 THEN 1 ELSE 0 END AS has_children
        FROM knowledge_garden_node n
        LEFT JOIN (
            SELECT parent_node_idx, COUNT(*) AS child_cnt
            FROM knowledge_garden_node
            WHERE partnership_member_idx = #{partnershipMemberIdx}
              AND state_cd = 'KNS0001'
            GROUP BY parent_node_idx
        ) c ON c.parent_node_idx = n.idx
        WHERE n.partnership_member_idx = #{partnershipMemberIdx}
          AND n.state_cd = 'KNS0001'
          /* parentId가 NULL이면 루트, 아니면 해당 parent의 자식 */
          AND (
                (#{parentNodeIdx} IS NULL AND n.parent_node_idx IS NULL)
                OR (#{parentNodeIdx} IS NOT NULL AND n.parent_node_idx = #{parentNodeIdx})
              )
          /* includeTypes (예: NOTE,CATEGORY) */
        <!-- includeTypes 가 있을 때만 type 필터 -->
        <if test="includeTypes != null and includeTypes.length > 0">
            AND n.type_cd IN
            <foreach collection="includeTypes" item="type" open="(" separator="," close=")">
                #{type}
            </foreach>
        </if>
        <if test="includeTypes == null or includeTypes.length == 0">
            AND n.type_cd IN ('KNT0001', 'KNT0002')
        </if>
        ORDER BY n.sort_order, n.label
        LIMIT #{limit};
    </select>

    <select id="selectByPartnershipMemberIdxWithLimit" resultType="KnowledgeGardenNodeVO">
        SELECT *
          FROM knowledge_garden_node
         WHERE partnership_member_idx = #{partnershipMemberIdx}
           AND state_cd = 'KNS0001'
        ORDER BY create_date DESC
        LIMIT #{limit}
    </select>

    <select id="selectByIdxInAndPartnershipMemberIdx" resultType="KnowledgeGardenNodeVO">
        SELECT *
          FROM knowledge_garden_node
         WHERE idx IN
        <foreach item="item" index="index" collection="neighborNodeIds" open="(" separator="," close=")">
            #{item}
        </foreach>
           AND partnership_member_idx = #{partnershipMemberIdx}
           AND state_cd = 'KNS0001'
    </select>

    <select id="selectNextSortOrder" resultType="Double">
        SELECT COALESCE(MAX(sort_order), 0) + 1
        FROM knowledge_garden_node
        WHERE partnership_member_idx = #{partnershipMemberIdx}
          AND state_cd = 'KNS0001'
          AND parent_node_idx <![CDATA[<=>]]> #{parentNodeIdx}
    </select>

    <select id="selectByPartnershipMemberIdxAndParentNodeIdx" resultType="KnowledgeGardenNodeVO">
        SELECT *
          FROM knowledge_garden_node
         WHERE partnership_member_idx = #{partnershipMemberIdx}
           AND state_cd = 'KNS0001'
           AND parent_node_idx <![CDATA[<=>]]> #{parentNodeIdx}
        ORDER BY sort_order, label
    </select>

    <select id="selectPrevByNodeIdx" resultType="KnowledgeGardenNodeVO">
        SELECT *
        FROM knowledge_garden_node
        WHERE state_cd = 'KNS0001'
          AND parent_node_idx <![CDATA[<=>]]> (
            SELECT parent_node_idx
            FROM knowledge_garden_node
            WHERE idx = #{targetNodeIdx}
        )
          AND sort_order <![CDATA[<]]> (
            SELECT sort_order
            FROM knowledge_garden_node
            WHERE idx = #{targetNodeIdx}
          )
        ORDER BY sort_order DESC
        LIMIT 1
    </select>

    <select id="selectNextByNodeIdx" resultType="KnowledgeGardenNodeVO">
        SELECT *
        FROM knowledge_garden_node
        WHERE state_cd = 'KNS0001'
          AND parent_node_idx <![CDATA[<=>]]> (
            SELECT parent_node_idx
            FROM knowledge_garden_node
            WHERE idx = #{targetNodeIdx}
        )
          AND sort_order > (
            SELECT sort_order
            FROM knowledge_garden_node
            WHERE idx = #{targetNodeIdx}
          )
        ORDER BY sort_order ASC
        LIMIT 1
    </select>

    <update id="updateByKnowledgeGardenNodeVO" parameterType="KnowledgeGardenNodeVO">
        UPDATE knowledge_garden_node
           SET label = #{label},
               type_cd = #{typeCd},
               parent_node_idx = #{parentNodeIdx},
               sort_order = #{sortOrder},
               depth = #{depth},
               current_version_idx = #{currentVersionIdx},
               state_cd = #{stateCd},
               note_status_cd = #{noteStatusCd},
               view_count = #{viewCount},
               update_date = NOW()
         WHERE idx = #{idx}
    </update>

    <update id="updateDepth">
        UPDATE knowledge_garden_node
           SET depth = #{newDepth},
               update_date = NOW()
         WHERE idx = #{nodeIdx}
    </update>

    <select id="selectChildrenByNodeIdx" resultType="KnowledgeGardenNodeVO">
        SELECT
            *
        FROM knowledge_garden_node
        WHERE parent_node_idx = #{nodeIdx}
          AND state_cd = 'KNS0001'
        ORDER BY sort_order ASC
    </select>

    <select id="selectByPmIdxAndSearchStrAndTypeCdInWithLimit" resultType="KnowledgeGardenNodeVO">
        SELECT
            DISTINCT n.*
        FROM knowledge_garden_node n
        LEFT JOIN knowledge_garden_node_version v
            ON v.idx = n.current_version_idx
        LEFT JOIN knowledge_garden_link l
            ON l.start_node_idx = n.idx
           AND l.type_cd = 'KLT0003'
        LEFT JOIN knowledge_garden_node k
            ON k.idx = l.end_node_idx
           AND k.type_cd = 'KNT0003'
        <where>
            n.partnership_member_idx = #{partnershipMemberIdx}
            AND n.state_cd = 'KNS0001'
            <if test="includeTypes != null and includeTypes.length > 0">
                AND n.type_cd IN
                <foreach collection="includeTypes" item="type" open="(" separator="," close=")">
                    #{type}
                </foreach>
            </if>
            <if test="searchStr != null and searchStr != ''">
                AND (
                    n.label LIKE CONCAT('%', #{searchStr}, '%')
                    OR k.label LIKE CONCAT('%', #{searchStr}, '%')
                )
            </if>
        </where>
        <if test="searchStr != null and searchStr != ''">
            ORDER BY
                COALESCE(v.create_date, n.update_date) DESC,
                n.idx DESC
        </if>
        <if test="searchStr == null or searchStr == ''">
            ORDER BY
                COALESCE(v.create_date, n.update_date) DESC,
                n.idx DESC
        </if>
        LIMIT #{limit}
    </select>

    <select id="selectLinkedNodeByStartNodeIdxAndTypeCd" resultType="KnowledgeGardenNodeVO">
        SELECT
            n.*
        FROM knowledge_garden_link l
        JOIN knowledge_garden_node n
            ON n.idx = l.end_node_idx
        WHERE l.start_node_idx = #{startNodeIdx}
          AND l.type_cd = #{typeCd}
          AND l.state_cd = 'KLS0001'
          AND n.state_cd = 'KNS0001'
    </select>

    <select id="selectSubtreeNodes" resultType="KnowledgeGardenNodeVO">
        WITH RECURSIVE subtree AS (
            SELECT *
            FROM knowledge_garden_node
            WHERE idx = #{rootNodeIdx}
              AND partnership_member_idx = #{partnershipMemberIdx}

            UNION ALL

            SELECT n.*
            FROM knowledge_garden_node n
            JOIN subtree s ON n.parent_node_idx = s.idx
            WHERE n.partnership_member_idx = #{partnershipMemberIdx}
        )
        SELECT *
        FROM subtree
    </select>

    <update id="updateStateByNodeIds">
        UPDATE knowledge_garden_node
        SET state_cd = #{stateCd},
        update_date = NOW()
        WHERE partnership_member_idx = #{partnershipMemberIdx}
        AND idx IN
        <foreach collection="nodeIds" item="id" open="(" separator="," close=")">
            #{id}
        </foreach>
    </update>

    <update id="updateCurrentVersionIdx">
        UPDATE knowledge_garden_node
           SET current_version_idx = #{currentVersionIdx},
               update_date = NOW()
         WHERE idx = #{nodeIdx}
    </update>

    <select id="selectTrashNodes" resultType="KnowledgeGardenNodeVO">
        SELECT *
          FROM knowledge_garden_node n
         WHERE n.partnership_member_idx = #{partnershipMemberIdx}
           AND n.state_cd = 'KNS0002' <!-- TRASH -->
        <if test="includeTypes != null and includeTypes.length > 0">
           AND n.type_cd IN
           <foreach collection="includeTypes" item="t" open="(" separator="," close=")">
               #{t}
           </foreach>
        </if>
        <if test="searchStr != null and searchStr != ''">
           AND n.label LIKE CONCAT('%', #{searchStr}, '%')
        </if>
         ORDER BY n.update_date DESC
         LIMIT #{limit}
    </select>

    <select id="selectBreadCrumbByNodeIdx" resultType="KnowledgeGardenNodeVO">
        WITH RECURSIVE breadcrumb AS (
            SELECT *
            FROM knowledge_garden_node
            WHERE idx = #{nodeIdx}
              AND partnership_member_idx = #{partnershipMemberIdx}
            UNION ALL
            SELECT n.*
            FROM knowledge_garden_node n
            JOIN breadcrumb b ON n.idx = b.parent_node_idx
            WHERE n.partnership_member_idx = #{partnershipMemberIdx}
        )
        SELECT *
        FROM breadcrumb
        ORDER BY depth ASC
    </select>
</mapper>